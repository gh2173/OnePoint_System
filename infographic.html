<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<title>Final Report</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
  <style>    :root {
      --main-bg: #f0f8ff;
      --main-text: #1a2233;
      --accent: #0066cc;
      --border: #0066cc;
      --step-bg: #ffffff;
      --icon-shadow: 2px 2px 0 #1a2233;
    }    html, body {
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: var(--main-bg);
      font-family: 'Noto Sans KR', Arial, sans-serif;
    }
    body {
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    .container {
      width: 100vw;
      height: 100vh;
      max-width: none;
      min-height: 0;
      margin: 0;
      border-radius: 0;
      box-shadow: none;
      padding: 0;
      position: relative;
      background: var(--main-bg) !important;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .container::before {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: url('nepesark.png') center center no-repeat;
      background-size: 60% auto;
      opacity: 0.8;
      pointer-events: none;
      z-index: 0;
      border-radius: 0;
      transform: rotate(-45deg);
      transition: opacity 0.3s, filter 0.3s;
    }
    .container > * {
      position: relative;
      z-index: 1;
    }
    h1 {
      font-size: 3.5vw;
      font-weight: 900;
      color: var(--main-text);
      margin: 1vw 0 0.5vw 0;
      text-align: center;
      letter-spacing: -0.1vw;
    }
    .desc {
      color: var(--main-text);
      font-size: 1.7vw;
      text-align: center;
      margin-bottom: 2vw;
      line-height: 1.6;
      font-weight: 700;
    }
    .timeline {
      position: relative;
      margin: 0;
      width: 100vw;
      max-width: none;
      height: 100%;
      padding: 0;
      display: flex;
      justify-content: stretch;
      align-items: center;
      flex: 1 1 0;
      overflow: visible;
    }
    .timeline::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      width: 100%;
      height: 0.5vw;
      background: var(--border);
      transform: translateY(-50%);
      z-index: 0;
      border-radius: 0.25vw;
    }
    .step {
      position: relative;
      flex: 1 1 0;
      min-width: 0;
      width: auto;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      margin: 0 calc(var(--step-margin, 1vw));
      font-size: calc(1vw * var(--step-scale, 1));
      /* transform은 JS에서 inline으로 적용 */
      max-width: 22vw;
    }
    .step-content {
      background: var(--step-bg);
      border: 0.2vw solid var(--border);
      border-radius: calc(1vw * var(--step-scale, 1));
      padding: calc(1vw * var(--step-scale, 1));
      margin: 0.5vw 0;
      width: 100%;
      box-sizing: border-box;
      font-size: calc(1.3vw * var(--step-scale, 1));
      color: var(--main-text);
      line-height: 1.4;
      font-weight: 700;
      text-align: center;
      box-shadow: 0 0.2vw 0.8vw rgba(0,0,0,0.08);
      max-height: calc(18vw * var(--step-scale, 1));
      overflow: auto;
    }
    .step-content strong {
      font-size: calc(1.5vw * var(--step-scale, 1));
      font-weight: 900;
      margin-bottom: calc(0.3vw * var(--step-scale, 1));
      color: var(--main-text);
    }
    .step-icon {
      width: calc(4vw * var(--step-scale, 1));
      height: calc(4vw * var(--step-scale, 1));
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--step-bg);
      border-radius: 50%;
      box-shadow: 0 0.2vw 0.8vw rgba(0,0,0,0.04);
      margin: calc(0.5vw * var(--step-scale, 1)) 0;
      flex-shrink: 0;
      border: 0.2vw solid var(--border);
    }
    .step-number {
      background: var(--main-bg);
      color: var(--main-text);
      font-size: calc(1.2vw * var(--step-scale, 1));
      font-weight: 900;
      border-radius: 50%;
      padding: calc(0.5vw * var(--step-scale, 1)) calc(1vw * var(--step-scale, 1));
      border: 0.3vw solid var(--border);
      margin: calc(0.5vw * var(--step-scale, 1)) 0;
      box-shadow: 0 0.2vw 0.8vw rgba(0,0,0,0.1);
      letter-spacing: -0.1vw;
      text-align: center;
    }
    .step-label {
      font-size: calc(1.3vw * var(--step-scale, 1));
      font-weight: 900;
      color: var(--main-text);
      margin-bottom: calc(0.2vw * var(--step-scale, 1));
    }
    .dashed {
      border-top: 0.3vw dashed var(--border);
      width: 80%;
      margin: 1vw auto 0 auto;
      opacity: 0.7;
    }
    .multi-item {
      margin-bottom: calc(0.5vw * var(--step-scale, 1));
      padding-bottom: calc(0.5vw * var(--step-scale, 1));
      border-bottom: 0.1vw solid rgba(255, 60, 0, 0.3);
      font-weight: 700;
    }
    .multi-item:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    .item-number {
      font-size: calc(2.1vw * var(--step-scale, 1));
      font-weight: 900;
      color: var(--accent);
      margin-bottom: calc(0.2vw * var(--step-scale, 1));
    }
    .footer {
      text-align: center;
      margin-top: 1vw;
      color: var(--main-text);
      font-size: 1.2vw;
      font-weight: 900;
      letter-spacing: 0.1vw;
    }
    .failcode-name {
      color: #ff3c00;
      font-weight: 900;
      font-size: 1.5vw;
      letter-spacing: -0.05vw;
      line-height: 1.2;
      display: inline-block;
    }
    /* Responsive */
    @media (max-width: 768px) {
      html, body, .container {
        width: 100vw;
        height: 100vh;
        min-height: 0;
        max-width: 100vw;
        padding: 0;
        margin: 0;
      }
      .timeline {
        flex-direction: column;
        padding: 0;
      }
      .timeline::before {
        display: none;
      }
      .step {
        width: 100%;
        transform: none !important;
        margin: 2vw 0;
      }
      .step-content {
        font-size: 2.8vw;
      }
      .step-icon {
        width: 8vw;
        height: 8vw;
      }
      .step-number {
        font-size: 2.5vw;
        padding: 1vw 2vw;
      }
      h1 {
        font-size: 5vw;
      }
      .desc {
        font-size: 2.5vw;
      }
      .footer {
        font-size: 2vw;
      }
    }
    /* 다크모드 지원 */
    @media (prefers-color-scheme: dark) {
      :root {
        --main-bg: #23272f;
        --main-text: #f7f7f7;
        --accent: #0400ff;
        --border: #7700ff;
        --step-bg: #2d313a;
        --icon-shadow: 2px 2px 0 #000;
      }
      html, body, .container {
        background: var(--main-bg) !important;
      }
      .container::before {
        opacity: 0.07 !important;
        filter: grayscale(1) brightness(0.2) !important;
      }
      .step-content, .step-icon, .step-number {
        background: var(--step-bg) !important;
        color: var(--main-text) !important;
        border-color: var(--border) !important;
      }
      .footer, .desc, h1, .step-label {
        color: var(--main-text) !important;
      }
      .dashed {
        border-top: 0.3vw dashed var(--border) !important;
      }
    }
  </style>
</head>
<body>
  <!-- 워터마크는 container 내부에만 적용, body에는 추가 div 필요 없음 -->
  <div class="container">
    <h1>Final Report</h1>
       <div class="timeline" id="timelineSteps">
      <!-- JS에서 동적으로 step-content 생성 -->
    </div>
    <div class="footer">
      © Design by HyperAutomation
    </div>
  </div>
  <script>    // 불량코드 그룹 정의
    const defectCodeGroups = [
      {
        group: '탐침불량',
        codes: [
          { code: '2', name: 'Probe_Damage', column: 'PROBE_DAMAGE' },
          { code: '4', name: 'Probe_Misalign', column: 'PROBE_MISALIGN' }
        ]
      },
      {
        group: 'Scratch/broken/Burnt',
        codes: [
          { code: '1', name: 'Burnt', column: 'BURNT' },
          { code: '3', name: 'Bump_Damage', column: 'BUMP_DAMAGE' },
          { code: '5', name: 'Pattern_Damage', column: 'PATTERN_DAMAGE' }
        ]
      }
    ];

    // 첨부된 테이블 기반 불량 원인 분석 매핑 데이터 (최신 텍스트 반영)
    const defectAnalysisTable = [
      // Scratch/Broken/burnt + Man
      { defectCode: 'Scratch/Broken/burnt', item: 'Man', causeType: 'Slot 엇갈림', action: '표준교육', verification: '사내교육일지' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Man', causeType: 'Cassette Loading Miss', action: '표준교육', verification: '사내교육일지' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Man', causeType: 'H-Bar Slot확인', action: '표준교육', verification: '사내교육일지' },

      // Scratch/Broken/burnt + Machine
      { defectCode: 'Scratch/Broken/burnt', item: 'Machine', causeType: 'Slot감지 Sensor 불량', action: 'Slot감지 Sensor 감도 측정/교체', verification: 'Corr. 1Hr 검증 및 결과 Report' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Machine', causeType: 'Driver Fail', action: 'Spare 교체 및 타 장비 Swap 검증', verification: 'Corr. 1Hr 검증 및 결과 Report' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Machine', causeType: 'Belt / Bolt 불량', action: '설비 정상 Part  고정 및 조정', verification: 'Corr. 1Hr 검증 및 결과 Report' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Machine', causeType: 'Wafer Un/Loading Position 불량', action: 'Un/Loading Position Re-setup', verification: 'Corr. 1Hr 검증 및 결과 Report' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Machine', causeType: 'Chuck 3-Pin 불량', action: '3PIN Height Re-setup 및 교체', verification: 'Corr. 1Hr 검증 및 결과 Report' },

      // Scratch/Broken/burnt + Environment
      { defectCode: 'Scratch/Broken/burnt', item: 'Environment', causeType: 'Chuck Table 유동성 이물', action: 'Chuck Cleaning', verification: '검사결과 Report' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Environment', causeType: 'Wafer Back Side 이물', action: '전/후 Lot 이물확인 공유', verification: '검사결과 Report' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Environment', causeType: 'Utility 이상', action: 'Un/Loading Position Re-setup', verification: '검사결과 Report' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Environment', causeType: '정전', action: '설비기술그룹 현황 확인.', verification: '조치 완료 Report' },

      // Scratch/Broken/burnt + Probecard
      { defectCode: 'Scratch/Broken/burnt', item: 'Probecard', causeType: '연장 Wire Height 불량', action: 'Repair 업체 반출 / P/C 담당자 및 제품 Eng’r 공유 / 동일 Device P/C Wire 상태 확인', verification: '진행된 Lot Inspection 확인' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Probecard', causeType: 'Needle Wire 연결불량', action: 'Repair 업체 반출 / P/C 담당자 및 제품 Eng’r 공유 / 동일 Device P/C Wire 상태 확인', verification: '진행된 Lot Inspection 확인' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Probecard', causeType: '장착 부속 연결 불량', action: 'Repair 업체 반출 / P/C 담당자 및 제품 Eng’r 공유 / 동일 Device P/C Wire 상태 확인', verification: '진행된 Lot Inspection 확인' },
      { defectCode: 'Scratch/Broken/burnt', item: 'Probecard', causeType: 'Probe Head Bolt 체결 불량', action: 'Repair 업체 반출 / P/C 담당자 및 제품 Eng’r 공유 / 동일 Device P/C Wire 상태 확인', verification: '진행된 Lot Inspection 확인' },

      // 탐침불량 + Man
      { defectCode: '탐침불량', item: 'Man', causeType: 'Needle Align Setting Miss(Human)', action: '표준교육', verification: '사내교육 일지' },
      { defectCode: '탐침불량', item: 'Man', causeType: 'Prober Contact 평탄도 오적용', action: '표준교육', verification: '사내교육 일지' },

      // 탐침불량 + Machine
      { defectCode: '탐침불량', item: 'Machine', causeType: 'Chuck Table 평탄도 불 일정', action: 'Chuck Table leveling 실시', verification: 'Corr 평가 결과 보고' },
      { defectCode: '탐침불량', item: 'Machine', causeType: 'Prober Index Miss(탐침 누적 오차)', action: 'AMDS 누적오차 Cal 실시', verification: 'Corr 평가 결과 보고' },

      // 탐침불량 + Environment
      { defectCode: '탐침불량', item: 'Environment', causeType: '공조 온/습도 Spec Out', action: '관련부서 확인 요청(설비기술)', verification: '온/습도 정실 실측확인' },
      { defectCode: '탐침불량', item: 'Environment', causeType: '유동성 /고착성 이물', action: '이물 Cleaning', verification: '진행 전 이물 육안확인' },
      { defectCode: '탐침불량', item: 'Environment', causeType: '유동성 /고착성 이물', action: '전 / 후 Lot 이물 확인', verification: 'Wafer 평탄도 확인' },
      { defectCode: '탐침불량', item: 'Environment', causeType: '유동성 /고착성 이물', action: 'Probe Card Needle 확인', verification: 'Scope 검사 결과 공유' },
      { defectCode: '탐침불량', item: 'Environment', causeType: '유동성 /고착성 이물', action: '불량 범위 확인', verification: 'Scope 검사 결과 공유' },

      // 탐침불량 + Probe Card
      { defectCode: '탐침불량', item: 'Probe Card', causeType: '§Probe Card align 불량', action: 'Repair 업체 반출 / 수시검사 / P/C 담당자 및 제품 Eng’r 공유', verification: 'Probe Mark 확인' },
      { defectCode: '탐침불량', item: 'Probe Card', causeType: '§Bend Length 짧다', action: 'Repair 업체 반출 / 수시검사 / P/C 담당자 및 제품 Eng’r 공유', verification: 'Probe Mark 확인' },
      { defectCode: '탐침불량', item: 'Probe Card', causeType: '§Dia. Spec Over', action: 'Repair 업체 반출 / 수시검사 / P/C 담당자 및 제품 Eng’r 공유', verification: 'Probe Mark 확인' },
      { defectCode: '탐침불량', item: 'Probe Card', causeType: '§Needle 평탄도', action: 'Repair 업체 반출 / 수시검사 / P/C 담당자 및 제품 Eng’r 공유', verification: 'Probe Mark 확인' }
    ];

    // 데이터 전달 방식: localStorage 또는 쿼리스트링(LOTID)
    function getAnalysisData() {
      // 1. localStorage에서 분석 데이터
      const data = localStorage.getItem('infographicAnalysisData');
      if (data) {
        try { 
          const parsedData = JSON.parse(data);
          console.log('localStorage에서 분석 데이터 로드:', parsedData);
          return parsedData;
        } catch { return null; }
      }
      // 2. opener에서 데이터
      if (window.opener && window.opener.window && window.opener.window.lastAnalysisData) {
        console.log('opener에서 분석 데이터 로드:', window.opener.window.lastAnalysisData);
        return window.opener.window.lastAnalysisData;
      }
      // 3. 쿼리스트링에서 LOTID만 추출
      const params = new URLSearchParams(window.location.search);
      const lotid = params.get('lotid');
      console.log('쿼리스트링에서 LOTID 추출:', lotid);
      return lotid ? { lotid } : null;
    }    function createStepContent({defectCodes, items, multipleInstances}) {
      const timeline = document.getElementById('timelineSteps');
      timeline.innerHTML = '';
      let stepNumber = 1;
      const steps = [];      // Step 1: 불량Code (탐침불량, Scratch/broken/Burnt 중 실제 데이터가 있는 그룹만)
      if (defectCodes.probe.length > 0 || defectCodes.scratch.length > 0) {
        let codeHtml = '';
        if (defectCodes.probe.length > 0) {
          codeHtml += `<strong>탐침불량</strong><br>`;
          // 탐침불량 FAILCODE 중 발생 건수가 가장 큰 하나만 표시
          codeHtml += `• <span class="failcode-name">${defectCodes.probe[0].name}</span><br>`;
        }
        if (defectCodes.scratch.length > 0) {
          if (defectCodes.probe.length > 0) codeHtml += `<br>`;
          codeHtml += `<strong>Scratch/broken/Burnt</strong><br>`;
          // Scratch/broken/Burnt FAILCODE 중 발생 건수가 가장 큰 하나만 표시
          codeHtml += `• <span class="failcode-name">${defectCodes.scratch[0].name}</span><br>`;
        }
        steps.push(`
          <div class="step">
            <div class="step-icon">
              <svg width="44" height="44" viewBox="0 0 44 44">
                <ellipse cx="22" cy="26" rx="8" ry="10" fill="#ffe000" stroke="#1a2233" stroke-width="2"/>
                <circle cx="22" cy="14" r="5" fill="#ff3c00" stroke="#1a2233" stroke-width="2"/>
                <line x1="19" y1="10" x2="16" y2="6" stroke="#1a2233" stroke-width="2"/>
                <line x1="25" y1="10" x2="28" y2="6" stroke="#1a2233" stroke-width="2"/>
                <text x="22" y="30" text-anchor="middle" font-size="10" fill="#1a2233" font-weight="bold" font-family="Arial">C</text>
              </svg>
            </div>
            <div class="step-content">
              <span class="step-label"><불량Code 확인></span><br>
              ${codeHtml}
              <div class="dashed"></div>
            </div>
            <div class="step-number"><span>단계</span>0${stepNumber}</div>
          </div>
        `);
        stepNumber++;
      }
      // Step 2: Item (불량 요인에 따라 - 다중 Item 지원)
      if (items && items.length > 0) {
        const itemsText = items.join(', '); // 여러 Item을 쉼표로 구분하여 표시
        steps.push(`
          <div class="step">
            <div class="step-icon">
              <svg width="44" height="44" viewBox="0 0 44 44">
                <rect x="10" y="10" width="24" height="24" rx="4" fill="#ffe000" stroke="#1a2233" stroke-width="2"/>
                <line x1="16" y1="18" x2="28" y2="18" stroke="#ff3c00" stroke-width="2"/>
                <line x1="16" y1="24" x2="28" y2="24" stroke="#ff3c00" stroke-width="2"/>
                <rect x="13" y="16" width="2.5" height="2.5" fill="#ff3c00"/>
                <rect x="13" y="22" width="2.5" height="2.5" fill="#ff3c00"/>
              </svg>
            </div>
            <div class="step-content">
              <span class="step-label"><문제원인 파악></span><br>
              <strong>${itemsText}</strong>
              <div class="dashed"></div>
            </div>
            <div class="step-number"><span>단계</span>0${stepNumber}</div>
          </div>
        `);
        stepNumber++;
      }
      // Step 3: 원인 유형 (다중 인스턴스 지원, 중복 제거)
      if (multipleInstances && multipleInstances.length > 0) {
        // 중복 제거된 원인 유형 추출
        const uniqueCauseTypes = [...new Set(multipleInstances.map(instance => instance.causeType))];
        let causeTypeHtml = '';
        uniqueCauseTypes.forEach((causeType, index) => {
          causeTypeHtml += `
            <div class="multi-item">
              <div class="item-number">${index + 1}. ${causeType}</div>
            </div>
          `;
        });
        steps.push(`
          <div class="step">
            <div class="step-icon">
              <svg width="44" height="44" viewBox="0 0 44 44">
                <circle cx="18" cy="18" r="8" fill="#ffe000" stroke="#1a2233" stroke-width="2"/>
                <rect x="24" y="24" width="10" height="3" rx="1.5" fill="#ff3c00" stroke="#1a2233" stroke-width="2" transform="rotate(45 29 25.5)"/>
                <rect x="17.2" y="13" width="1.6" height="6" rx="0.8" fill="#ff3c00"/>
                <circle cx="18" cy="21" r="1.2" fill="#ff3c00"/>
              </svg>
            </div>
            <div class="step-content">
              <span class="step-label"><원인 유형 파악></span><br>
              ${causeTypeHtml}
              <div class="dashed"></div>
            </div>
            <div class="step-number"><span>단계</span>0${stepNumber}</div>
          </div>
        `);
        stepNumber++;
        // Step 4: 조치사항 (다중 인스턴스 지원, 중복 제거)
        // 중복 제거된 조치사항 추출
        const uniqueActions = [...new Set(multipleInstances.map(instance => instance.action))];
        let actionHtml = '';
        uniqueActions.forEach((action, index) => {
          actionHtml += `
            <div class="multi-item">
              <div class="item-number">${index + 1}. ${action}</div>
            </div>
          `;
        });
        steps.push(`
          <div class="step">
            <div class="step-icon">
              <svg width="44" height="44" viewBox="0 0 44 44">
                <rect x="12" y="10" width="20" height="24" rx="4" fill="#ffe000" stroke="#1a2233" stroke-width="2"/>
                <rect x="18" y="8" width="8" height="4" rx="2" fill="#ff3c00" stroke="#1a2233" stroke-width="2"/>
                <polyline points="18,26 22,30 28,22" fill="none" stroke="#ff3c00" stroke-width="2"/>
              </svg>
            </div>
            <div class="step-content">
              <span class="step-label"><조치사항 확인></span><br>
              ${actionHtml}
              <div class="dashed"></div>
            </div>
            <div class="step-number"><span>단계</span>0${stepNumber}</div>
          </div>
        `);
        stepNumber++;
        // Step 5: 조치 검증 (다중 인스턴스 지원, 중복 제거)
        // 중복 제거된 조치 검증 추출
        const uniqueVerifications = [...new Set(multipleInstances.map(instance => instance.verification))];
        let verificationHtml = '';
        uniqueVerifications.forEach((verification, index) => {
          verificationHtml += `
            <div class="multi-item">
              <div class="item-number">${index + 1}. ${verification}</div>
            </div>
          `;
        });
        steps.push(`
          <div class="step">
            <div class="step-icon">
              <svg width="44" height="44" viewBox="0 0 44 44">
                <path d="M22 8 L34 14 V24 C34 32 22 38 22 38 C22 38 10 32 10 24 V14 Z" fill="#ffe000" stroke="#1a2233" stroke-width="2"/>
                <polyline points="16,22 21,28 28,18" fill="none" stroke="#ff3c00" stroke-width="2"/>
              </svg>
            </div>
            <div class="step-content">
              <span class="step-label"><조치 검증 확인></span><br>
              ${verificationHtml}
              <div class="dashed"></div>
            </div>
            <div class="step-number"><span>단계</span>0${stepNumber}</div>
          </div>
        `);
      }
      // === step 개수에 따라 scale, offset, margin 동적 적용 ===
      const n = steps.length;
      const stepScale = Math.min(1.15, Math.max(0.6, 2.5 / n));
      const maxOffset = Math.max(7, Math.min(18, 36 / n));
      const stepMargin = Math.max(0.5, Math.min(2, 3 / n));
      document.documentElement.style.setProperty('--step-scale', stepScale);
      document.documentElement.style.setProperty('--step-offset', maxOffset + 'vw');
      document.documentElement.style.setProperty('--step-margin', stepMargin + 'vw');
      // step 렌더링 (zigzag transform)
      timeline.innerHTML = steps.map((html, i) => {
        const offset = (i % 2 === 0 ? -maxOffset : maxOffset);
        return html.replace('<div class="step"', `<div class=\"step\" style=\"transform: translateY(${offset}vw);\"`);
      }).join('');
    }    function analyzeAndRender() {
      const data = getAnalysisData();
      console.log('분석 데이터:', data);
      
      if (!data || !data.lotData) {
        document.getElementById('timelineSteps').innerHTML = '<div style="color:red;text-align:center;padding:20px;">분석 데이터가 없습니다.<br><small>index2.html에서 LOTID 분석을 먼저 실행해주세요.</small></div>';
        return;
      }
        // 1. 불량Code 그룹별로 발생 건수가 가장 큰 FAILCODE만 추출
      const getTopFailcode = (codes) => {
        const codesWithCount = codes.map(c => {
          const totalCount = data.lotData.reduce((sum, row) => sum + Number(row[c.column] || 0), 0);
          return { ...c, count: totalCount };
        }).filter(c => c.count > 0);
        
        if (codesWithCount.length === 0) return [];
        
        // 가장 큰 count를 가진 FAILCODE만 반환
        const maxCount = Math.max(...codesWithCount.map(c => c.count));
        return codesWithCount.filter(c => c.count === maxCount);
      };
      
      const probeCodes = getTopFailcode(defectCodeGroups[0].codes);
      const scratchCodes = getTopFailcode(defectCodeGroups[1].codes);
      
      console.log('탐침불량 최고 발생 코드:', probeCodes);
      console.log('Scratch/broken/Burnt 최고 발생 코드:', scratchCodes);
        // 2. Item: 불량 요인
      let items = []; // 배열로 변경하여 다중 Item 지원
      if (data.rootCause === '카드 원인') {
        items = ['Probecard'];
      } else if (data.rootCause === '장비 원인') {
        items = ['Machine'];
      } else if (data.rootCause === '인적 원인') {
        items = ['Man'];
      } else {
        // 기타인 경우 Man과 Environment 모두 포함
        items = ['Man', 'Environment'];
      }
      
      // 3. 불량Code 결정 (우선순위: 탐침불량 > Scratch/broken/Burnt)
      let defectCodeGroup = '';
      if (probeCodes.length > 0) {
        defectCodeGroup = '탐침불량';
      } else if (scratchCodes.length > 0) {
        defectCodeGroup = 'Scratch/Broken/burnt';
      }
      
      console.log('선택된 불량Code 그룹:', defectCodeGroup);
      console.log('선택된 Items:', items);
      
      // 4. 테이블에서 해당 (불량Code, Item) 조합의 모든 인스턴스 추출 (다중 Item 지원)
      const matchedInstances = defectAnalysisTable.filter(row => 
        row.defectCode === defectCodeGroup && items.includes(row.item)
      );
        console.log('매칭된 인스턴스들:', matchedInstances);
      
      // 5. step 생성
      createStepContent({
        defectCodes: { probe: probeCodes, scratch: scratchCodes },
        items,
        multipleInstances: matchedInstances
      });
    }
    
    document.addEventListener('DOMContentLoaded', analyzeAndRender);
  </script>
</body>
</html>